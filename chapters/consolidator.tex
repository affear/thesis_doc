%!TEX root = ../thesis.tex
%%--------------------------------------------------------------------------
%% NOVA CONSOLIDATOR
%%--------------------------------------------------------------------------
OpenStack already performs virtual machine placement. This is accomplished thanks to its \texttt{nova-scheduler} service. Once a virtual machine is created (or, in certain cases, resized or live migrated) the scheduler decides which of the available compute nodes can host\footnote{The policies by which a node can host or not a virtual machine are defined by the precise filter which scheduler has been equipped with.} the virtual machine (this phase is called \textit{filtering}) and then selects the best\footnote{Again, it depends on which weighter is used.} among them (this phase is called \textit{weighting}).

OpenStack \emph{doesn't} perform virtual machine consolidation. Each of the operations on virtual machines are issued by the user that owns them (or by \texttt{Heat} for him/her).

Virtual machine consolidation is a technique by which virtual machines locations on hosts are changed to achieve a better resource utilization in the whole system. Thus, virtual machines are periodically live (or cold) migrated to other hosts if some policy determines that its place is the wrong in that precise moment. The policy adopted is determined by the \emph{consolidation algorithm} used.

To add virtual machine consolidation feature to OpenStack we added a service to \texttt{Nova} called \texttt{nova-consolidator}. The new service is implemented in module \code{nova.consolidator} which provides a \code{nova.consolidator.base.BaseConsolidator} class which can be extended to write custom consolidators (see section \ref{sec:cons_base}) and some consolidation algorithms, both custom and taken from the state of the art (see section \ref{sec:cons_algs}).

\section{Consolidator Base}
\label{sec:cons_base}

Almost every service into OpenStack has three main components, the \emph{command}\footnote{In our case, \code{nova.cmd.consolidator}.} (its function \code{main} will be executed at service startup); the \emph{manager}\footnote{In our case, \code{nova.consolidator.manager}.}, which contains the real logic of the service and the \emph{RPC\footnote{Remote Procedure Call} API}\footnote{In our case, \code{nova.consolidator.rpcapi}}, which is used among OpenStack services to communicate\footnote{\url{https://github.com/affear/nova/tree/n-cons/nova/consolidator}}.

The command basically instantiates a \code{nova.service.Service} object with name ``\texttt{nova-consolidator}''. The service, in turn, instantiates a \code{nova.consolidator.manager.ConsolidatorManager} object; starts its RPC server and its \emph{periodic tasks}. As we can see in listing \ref{lst:cons_manager}\footnote{\label{note:cons_code}The code has been properly cut to fit the page and the reader needs.}, \code{ConsolidatorManager} exposes only one periodic task which is \code{consolidate} method.
Its period is defined in \texttt{/etc/nova/nova.conf} file (which can be edited using DevStack. See ~\ref{sub:fakestack_conf}) in option \texttt{consolidation\_interval} as well as the consolidator class used by the manager. When the manager is created a consolidator object is obtained using the \texttt{consolidator\_class} provided. Then, periodically, \code{consolidate} task is invoked. \code{consolidate} function \emph{delegates} consolidation to the consolidator object obtaining the necessary migrations to be performed. Once migrations are obtained, they are applied using \texttt{nova-compute}'s API.

The consolidator class is, by default, \code{nova.consolidator.base.BaseConsolidator} (see listing \ref{lst:cons_base}\footnoteref{note:cons_code}), which does nothing but defining a base class to be extended with real consolidation algorithms. Its \code{get\_migrations} method, in fact, returns an empty list of migrations. The most important method in \code{BaseConsolidator} is \code{consolidate}, which is the method the manager delegates consolidation to.

This method creates a snapshot of the system (see \ref{sub:cons_obj}) and passes it to \code{get\_migrations} method. \code{get\_migrations} will implement the consolidation algorithm desired. Eventually, a transitive closure on migrations is applied\footnote{If instance $I$ is moved first to host $A$ and then to host $B$; instance $I$ is only moved to host $B$.} and the migrations are returned to the manager.

\begin{lstlisting}[
	float,
	language=python,
	caption={Code for \code{nova.consolidator.manager.ConsolidatorManager}},
	label={lst:cons_manager},
	tabsize=2
]
class ConsolidatorManager(manager.Manager):

	def __init__(self, *args, **kwargs):
		self.compute_api = compute_api.API()
		self.consolidator = importutils.\
			import_class(CONF.consolidator_class)()
		# lines skipped

	@periodic_task.\
		periodic_task(spacing=CONF.consolidation_interval)
	def consolidate(self, ctxt):
		migrations = self.consolidator.consolidate(ctxt)
		for m in migrations:
			self._do_live_migrate(ctxt, m)

	def _do_live_migrate(self, ctxt, migration):
		instance = migration.instance
		host_name = migration.host.host
		# exception catching skipped
		self.compute_api.live_migrate(
			ctxt, instance,
			False, False, host_name
		)
\end{lstlisting}

\begin{lstlisting}[
	float,
	language=python,
	caption={Code for \code{nova.consolidator.base.BaseConsolidator}},
	label={lst:cons_base},
	tabsize=2
]
class BaseConsolidator(object):

	class Migration(object):
		def __init__(self, instance, host):
			super(BaseConsolidator.Migration, self).__init__()
			self.instance = instance
			self.host = host

	# _transitive_closure method
	# implementation skipped

	def consolidate(self, ctxt):
		snapshot = Snapshot(ctxt)
		migs = self.get_migrations(snapshot)
		return self._transitive_closure(migs)

	def get_migrations(self, snapshot):
		return []
\end{lstlisting}

\subsection{Objects}
\label{sub:cons_obj}
We thought that it wouldn't have been fair to leave to the user the duty to learn and understand OpenStack's complex database APIs.
Due to this fact, we developed \code{nova.consolidator.objects}, which is a module that defines an abstraction of system snapshot to be used in method \code{get\_migrations} by developers. The module provides the class \code{nova.consolidator.objects.Snapshot}. A \code{Snapshot} object offers attributes to access all information about the system, such as current active nodes and instances both for each node and, generally, in the system itself. The \code{Snapshot} is thought to be renewed at each consolidation cycle. So, any attribute is lazily obtained on its first call: subsequent invocations of that attribute won't refresh snapshot's state. The Snapshot is, thus, entirely cached\footnote{Once an instance or a compute node is obtained it will not be queried again on OpenStack's database. Its status is \emph{frozen} at the moment the first query has been performed. To refresh a \code{Snapshot} it is necessary to create a new \code{Snapshot} object.}.

In detail, a \code{Snapshot} object offers active nodes (\code{nodes} attribute) and all, running, migrable\footnote{According to us, an instance is \emph{migrable} when its state is \texttt{ACTIVE} and its power state id \texttt{RUNNING}.} and not instances. Instances are \code{nova.objects.instance.Instance}\footnote{\url{https://github.com/openstack/nova/blob/master/nova/objects/instance.py}} objects; nodes are wrappers for \code{nova.objects.compute\_node.ComputeNode}\footnote{\url{https://github.com/openstack/nova/blob/master/nova/objects/compute_node.py}} objects, which add the possibility to get all, running, migrable and not instances per compute node.

In any case, the developer is not thought to instantiate \code{Snapshot} objects, because this is up to \code{consolidate} method, which already instantiates and passes the current system snapshot to method \code{get\_migrations}, which is the \emph{only} method which needs to be overridden by the user in a custom consolidator class.

In listing \ref{lst:cons_snapshot} we provide an example of using a \code{Snapshot} in a python script.

\begin{lstlisting}[
	float,
	language=python,
	caption={An example of using a \code{Snapshot} object},
	label={lst:cons_snapshot},
	tabsize=2
]
from nova import config, objects, context
from nova.consolidator.objects import Snapshot

# Init operations
config.parse_args('')
objects.register_all()
ctxt = context.get_admin_context()

# Using the Snapshot
s = Snapshot(ctxt)
nodes = snapshot.nodes # all compute nodes
node = nodes[0] # the first node
instances = node.instances # all instances on that node (list)
print node.vcpu
print node.id
print instances[0].flavor
# `node` has all attributes as
# nova.objects.compute_node.ComputeNode has,
# as well as `instances[0]` has all attributes as
# nova.objects.instance.Instance has.

nodes_new = snapshot.nodes
# nodes are not refreshed because they are cached!
assert nodes == nodes_new # evaluates to True
\end{lstlisting}

\section{Algorithms}
\label{sec:cons_algs}
In this section, we explain in detail consolidation algorithms that we implemented in our \texttt{nova-consolidator}. Each of the algorithms proposed is run inside a consolidator class that inherits from \code{nova.consolidator.base.BaseConsolidator}, inside \code{get\_migrations} method.

\subsection{Random Algorithm}
\label{sub:algs_rnd}
The first algorithm we implemented is the random one\footnote{\url{https://github.com/affear/nova/blob/n-cons/nova/consolidator/base.py}}. This algorithm was implemented for testing purpose and to see if even randomization could bring improvement in resource optimization, given that virtual machines are never moved in OpenStack\footnote{Except for when a user decides to, or on a resize call. When a virtual machine is resized to a flavor which is too big for the current host, it is migrated to a suitable one.}.

The algorithm takes, by configuration, a percentage of migrable instances to be migrated to other compute nodes. Instances are randomly chosen from hosts and their destination is randomly chosen among remaining hosts. Choices are not taken taking into account host suitability. The algorithm by itself doesn't rely on the fact that migrations will be applied. If a migration fails, due to resource usage problems, it is not a problem.

Random algorithm is highlighted in in listing \ref{lst:rnd_alg}\footnoteref{note:cons_code}.

\begin{lstlisting}[
	float,
	language=python,
	caption={Code for random algorithm},
	label={lst:rnd_alg},
	tabsize=2
]
def get_migrations(self, snapshot):
	nodes = snapshot.nodes
	no_nodes = len(nodes)
	migration_percentage = float(CONF.consolidator.migration_percentage) / 100
	no_inst = len(snapshot.instances_migrable)
	no_inst_migrate = int(no_inst * migration_percentage)

	# if no_inst_migrate == 0
	# or no_nodes < 2, then
	# return empty list.
	# Cannot migrate.

	migs = []
	while no_inst_migrate > 0:
		nodes_cpy = list(nodes) # copy nodes list

		from_host = choose_host(nodes_cpy)
		# choose_host code is skipped.
		# The chosen node is randomly chosen
		# taking into account that it has to host
		# at least one instance.

		inst_on_host = from_host.instances_migrable
		no_inst_on_host = len(inst_on_host)

		top_bound = min(no_inst_on_host, no_inst_migrate)
		n = random.randint(1, top_bound)
		no_inst_migrate -= n

		instances = random.sample(inst_on_host, n)
		nodes_cpy.remove(from_host) # do not choose same host
		to_host = random.choice(nodes_cpy)
		for i in instances:
			migs.append(self.Migration(i, to_host))

	return migs
\end{lstlisting}

\subsection{Genetic Algorithm}
\label{sub:algs_rnd}

\subsection{Holistic Algorithm}
\label{sub:algs_rnd}